#!/usr/bin/env bb
(ns music.dl
  (:require
   [babashka.http-client :as http]
   [babashka.cli :as cli]
   [babashka.process :as p]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.set :as set]
   [cheshire.core :as json]))

(def host "https://wyapi-2.toubiec.cn/api")
(def m-plist (str host "/getPlaylistDetail"))
(def m-info (str host "/getSongDetail"))
(def m-lyric (str host "/getLyric"))
(def m-url (str host "/getMusicUrl"))

(def netease-api "https://music.163.com/api")
(def netease-search-api (str netease-api "/search/get/web?csrf_token=hlpretag=&hlposttag=&offset=0&total=true&limit=20&type=%d&s=%s"))
(def netease-lyric-api (str netease-api "/song/lyric?os=pc&lv=-1&id="))
(def args (cli/parse-opts *command-line-args* {:verbose false}))

;; standard：标准音质, exhigh：极高音质,
;; lossless：无损音质 hires：Hi-Res音质,
;; jyeffect：高清环绕声, sky：沉浸环绕声,
;; jymaster：超清母带
(def level (atom ""))
(def playlist (atom "./"))

(def usage-doc
  (str"Usage:\n"
      "  -pid,\tPlay list ID\n"
      "  -sid,\tSong ID\n"
      "  -qs,\tQuery song name\n"
      "  -ql,\tQuery song list\n\n"
      "Optional:\n"
      "  --dl,\tDownload lyric (default disable)\n"
      "  -l,\tQuality level (default exhigh)\n"
      "  \t(level: standard,exhigh,lossless,hires,jyeffect,sky,jymaster)"))

(def headers
  {"Content-Type" "application/json"
   "Accept" "application/json"
   "User-Agent" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
   "Sec-Fetch-Mode" "cors"
   })

(defn- link-request
  ([url]
   (-> (http/get url {:headers headers})
       :body
       (json/parse-string true)))
  ([url args]
   (-> (http/post url {:headers headers :body (json/generate-string args)})
       :body
       (json/parse-string true))))
     
(def qargs
  {:qs {:type 1
        :fun (fn [x]
               (->> x
                    :songs
                    (map #(hash-map :id (:id %) :desc (str (:name %) " - " (:name (first (:artists %))))))))}
   :ql {:type 1000
        :fun (fn [x]
               (->> x
                    :playlists
                    (map #(hash-map :id (:id %) :desc
                                    (format "%s - (共 %d 首) - (播放量:%d) - (收藏量:%d)"
                                            (:name %) (:trackCount %) (:playCount %) (:bookCount %))))))}})

(defn- select-music [qlist]
  (doseq [ql qlist]
    (println (str (first ql) ". " (:desc (last ql)))))
  (println "input number:")
  (let [choice (Integer/parseInt (read-line))
        selected (last (nth qlist choice))]
    (println "selected:" (:desc selected))
    (println "id:" (:id selected))
    (:id selected)))

(defn- query-music [qarg name]
  (let [type (:type qarg)
        fun (:fun qarg)]
    (->>
     (link-request (format netease-search-api type name))
     :result
     fun
     (map-indexed vector))))

(defn- check-link [link]
  (cond
    (nil? link) " -- 已失效"
    (str/includes? link ".mp3") ".mp3"
    (str/includes? link ".flac") ".flac"))

(defn- get-music-dlink [sid]
  (-> (link-request m-url {:id (str sid) :level @level})
      :data
      ((keyword (str sid)))
      :url))

(defn- handle-song-info [s-info]
  (let [picurl (if (contains? s-info :picUrl) (:picUrl s-info) (:picimg s-info))
        singer (if (contains? s-info :artists) (:artists s-info) (:singer s-info))]
    {:id (:id s-info)
     :picurl picurl
     :title (:name s-info)
     :album (:album s-info)
     :singer singer
     :path (str @playlist (str/replace (:name s-info) "/" " ") " - " (str/replace singer "/" "&"))
     }))

(defn- get-music-list [pid]
  (println "Get playlist...")
  (let  [data (:data (link-request m-plist {:id (str pid)}))]
    ;; 创建歌单目录
    (println "Create playlist dir...")
    (when (not (.exists (io/file (:name data))))
      (.mkdir (io/file (:name data))))
    ;; 设置歌单名变量
    (println "Set playlist dir var...")
    (reset! playlist (str "./" (:name data) "/"))
    (->> data
         :tracks
         (map handle-song-info))))

(defn- get-music-info [sid]
  (-> (link-request m-info {:id (str sid)})
      :data
      handle-song-info))

(defn- file-exists? [path]
  (if (not (.exists (io/file path)))
    (do (println (str "Downloading -> " path))
        false)
    (do (println (str "Exists..." path))
        (Thread/sleep 1000)
        true)))

(defn- download-lyric [sobj]
  (let [path (str (:path sobj) ".lrc")]
    (when (not (file-exists? path))
      (let [data (:data (link-request m-lyric {:id (str (:id sobj))}))
            lyric (if (= (:tlyric data) "")
                    (:lrc data)
                    (->> data
                         ((fn [x] (str (:lrc x) (:tlyric x))))
                         (#(str/replace % "[" ""))
                         (str/split-lines)
                         (map #(str/split % #"]"))
                         (reduce (fn [acc [k v]] (update acc (keyword (str k)) (fnil conj []) v)) (sorted-map))
                         (map #(str "[" (name (first %)) "]" (str/join " / " (remove nil? (second %)))))
                         (str/join "\n")))]
        (spit path lyric)))))

(defn- download-music [sobj]
  ;; (print sobj)
  (let [dlink (get-music-dlink (:id sobj))
        f-path (str (:path sobj) (check-link dlink))
        f-args ["-i" dlink
                "-i" (:picurl sobj)
                "-c" "copy"
                "-map" "0"
                "-map" "1"
                "-disposition:v:0" "attached_pic"
                "-metadata" (str "title=" (:title sobj))
                "-metadata" (str "album=" (:album sobj))
                "-metadata" (str "artist=" (:singer sobj))
                "-metadata" (str "Source=http://music.163.com/song?id=" (:id sobj))
                f-path]]
    (when (not (file-exists? f-path))
      (apply p/sh "ffmpeg" f-args))))

(defn- main []
  (let [flag (count (set/intersection (set (keys args)) #{:pid :sid :qs :ql}))
        exec (if (contains? args :dl)
               (fn [x] (download-music x) (download-lyric x))
               (fn [x] (download-music x)))]
    (reset! level (get args :l "exhigh"))
    (if (not= 1 flag)
      (println usage-doc)
      (do (println "Start...")
          (cond
            (contains? args :pid) (->> (get-music-list (:pid args))
                                       (map exec)
                                       doall)
            (contains? args :sid) (->> (get-music-info (:sid args))
                                       exec)
            (contains? args :qs) (->> (query-music (:qs qargs) (:qs args))
                                      select-music
                                      get-music-info
                                      exec)
            (contains? args :ql) (->> (query-music (:ql qargs) (:ql args))
                                      select-music
                                      get-music-list
                                      (map exec)
                                      doall))
          (println "Finish!")))))

(main)
