#!/usr/bin/env bb
(ns music.dl
  (:import
   [java.net URI URLEncoder])
  (:require
   [babashka.http-client :as http]
   [babashka.cli :as cli]
   [babashka.fs :as fs]
   [babashka.process :as p]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.set :as set]
   [cheshire.core :as json]
   [clj-yaml.core :as yaml]))

(def conf-path (str (.getParent (fs/real-path *file*)) "/config.yaml"))

(def conf-data (yaml/parse-string (slurp conf-path)))
(def api-data (:api conf-data))
(def opt-data (:opt conf-data))

(def host ((keyword (:api opt-data)) api-data))
(def m-info  (str host (api-data :info)))
(def m-album (str host (api-data :album)))
(def m-plist (str host (api-data :list)))
(def m-lyric (str host (api-data :lyric)))
(def m-url   (str host (api-data :durl)))

(def netease-api "https://music.163.com/api")
(def netease-song-api (str netease-api "/song/detail/?id=%d&ids=[%d]"))
(def netease-search-api (str netease-api "/search/get/web?csrf_token=hlpretag=&hlposttag=&offset=0&total=true&limit=20&type=%d&s=%s"))
(def netease-lyric-api (str netease-api "/song/lyric?os=pc&lv=-1&id="))
(def args! (atom (cli/parse-opts *command-line-args* {:verbose false}) ))

(def fname-regex #"[`?*<>\|\"]")

(def usage-doc
  (str"Usage:\n"
      "  -pid,\tPlay list ID\n"
      "  -aid,\tAlbum ID\n"
      "  -sid,\tSong ID\n"
      "  -qs,\tQuery song name\n"
      "  -ql,\tQuery song list\n\n"
      "Optional:\n"
      "  -dl,\tDownload lyric mode\n"
      "  -l,\tQuality level\n"))

(def headers
  {"Content-Type" "application/json"
   "Accept" "application/json"
   "User-Agent" "curl/8.17.0"
   "Sec-Fetch-Mode" "cors"})

(def client (http/client (assoc-in http/default-client-opts [:ssl-context :insecure] true)))
(defn- request-url
  ([url]
   (request-url url nil))
  ([url arg]
   (let [resp (if arg
               (http/post url {:headers headers :body (json/generate-string arg) :client client})
               (http/get url {:headers headers}))]
     {:status (:status resp) :body (json/parse-string (:body resp) true)})))
     
(def qargs
  {:qs {:type 1
        :fn (fn [x]
               (->> x
                    :songs
                    (map #(hash-map :id (:id %) :desc (str (:name %) " - " (:name (first (:artists %))))))))}
   :ql {:type 1000
        :fn (fn [x]
               (->> x
                    :playlists
                    (map #(hash-map :id (:id %) :desc
                                    (format "%s - (共 %d 首) - (播放量:%d) - (收藏量:%d)"
                                            (:name %) (:trackCount %) (:playCount %) (:bookCount %))))))}})

(defn- select-music [qlist]
  (doseq [ql qlist]
    (println (str (first ql) ". " (:desc (last ql)))))
  (println "input number:")
  (let [choice (Integer/parseInt (read-line))
        selected (last (nth qlist choice))]
    (println "selected:" (:desc selected))
    (println "id:" (:id selected))
    (:id selected)))

(defn- query-music [qarg name]
  (let [type (:type qarg)
        fn (:fn qarg)]
    (->> (request-url (format netease-search-api type (URLEncoder/encode name)))
         :body
         :result
         fn
         (map-indexed vector))))

(defn- check-link [link]
  (cond
    (nil? link) " -- 已失效"
    (str/includes? link ".mp3") ".mp3"
    (str/includes? link ".flac") ".flac"))

(defn- get-music-durl [sid]
  (let [resp (request-url m-url {:id (str sid) :level (:l @args!)})
        status (:status resp)
        body (:body resp)
        durl ((fn [x] (:url (first x))) (:data body))]
    ;; (println durl)
    durl))

(defn- handle-song-info [s-info]
  (let [picurl (if (contains? s-info :picUrl) (:picUrl s-info) (:picimg s-info))
        singer (if (contains? s-info :artists) (:artists s-info) (:singer s-info))
        nm-info (first (:songs (:body (request-url (format netease-song-api (:id s-info) (:id s-info))))))
        nm-album (:album nm-info)
        p-time (long (:publishTime nm-album))]
    ;; (println (:name nm-info))
    ;; (println (:id nm-info))
    ;; (println (str (:publishTime nm-album) "-" (:name nm-info) "-" (:id nm-info)))
    {:id (:id s-info)
     :picurl picurl
     :name (:name s-info)
     :album (:album s-info)
     :singer singer
     :song-no (:no nm-info)
     :song-alias (if (empty? (:alias nm-info)) nil (str/join "," (:alias nm-info)))
     :song-trans (:transName nm-info)
     :album-id (:id nm-album)
     :album-artists (str/join "," (map #(:name %) (:artists nm-album)))
     :album-trans (:transName nm-album)
     :album-type (:type nm-album)
     :album-sub-type (:subType nm-album)
     :album-size (:size nm-album)
     :album-company (:company nm-album)
     :album-publish-time (if (#{0 -28800000} p-time)
                           "" (.format (java.text.SimpleDateFormat. "yyyy-MM-dd") (java.util.Date. p-time)))
     :path (str (:path @args!) (str/replace
                                (str/replace (str (:name s-info) " - " singer ) "/" "&")
                                fname-regex ""))}))

(defn- handle-mlist-info [id,url]
  (println "Get playlist...")
  (let  [data (:data (:body (request-url url {:id (str id)})))]
    ;; 设置歌单名变量
    (println "Set playlist dir var...")
    (swap! args! assoc :path (str "./" (str/replace (str/replace (:name data) #"[:/]" "_") fname-regex "") "/"))
    (println @args!)
    ;; (println data)
    ;; 创建歌单目录
    (println "Create playlist dir...")
    (when (not (.exists (io/file (:path @args!))))
      (.mkdir (io/file (:path @args!))))
    data))

(defn- get-music-list [pid]
  (->> (handle-mlist-info pid m-plist)
       :tracks
       (map handle-song-info)))

(defn- get-album-list [aid]
  (let [data (handle-mlist-info aid m-album)]
    (->> data
         :tracks
         (map #(assoc % :picUrl (data :picUrl)))
         (map handle-song-info))))

(defn- get-music-info [sid]
  (->> (request-url m-info {:id (str sid)})
      :body
      :data
      (#(handle-song-info %))))

(defn- get-lyric [sid]
  (let [data (:data (:body (request-url m-lyric {:id (str sid)})))]
    (if (= (:tlyric data) "")
      (:lrc data)
      (->> data
           ((fn [x] (str (:lrc x) (:tlyric x))))
           (#(str/replace % "[" ""))
           (str/split-lines)
           (map #(str/split % #"]"))
           (reduce (fn [acc [k v]] (update acc (keyword (str k)) (fnil conj []) v)) (sorted-map))
           (map flatten)
           ;; 同一行
           ;; (map #(str "[" (name (first %) ) "]" (str/join " / " (remove nil? (rest %)))))
           ;; 换行
           (map #(str "[" (name (first %)) "]" (second %)
                      (when (= 3 (count (remove nil? %)))
                        (str "\n" "[" (name (first %)) "]" (last %)))))
           (str/join "\n")))))

(defn- file-exists? [path]
  (if (not (.exists (io/file path)))
    (do (println (str "Downloading -> " path))
        false)
    (do (println (str "Exists..... -> " path))
        (Thread/sleep 1000)
        true)))

(defn- download-music [sobj]
  ;; (print (:album-publish-time sobj))
  (let [durl (get-music-durl (:id sobj))
        suffix (check-link durl)
        f-path (str (:path sobj) suffix)
        l-path (str (:path sobj) ".lrc")
        lyric (get-lyric (:id sobj))
        f-args ["-i" durl
                "-i" (:picurl sobj)
                "-c" "copy"
                "-map" "0"
                "-map" "1"
                "-disposition:v:0" "attached_pic"
                "-metadata" "encoded_by=ffmpeg"
                "-metadata" (str "lyrics=" lyric)
                "-metadata" (str "title=" (:name sobj))
                "-metadata" (str "artist=" (:singer sobj))
                "-metadata" (str "album=" (:album sobj))
                "-metadata" (str "album_artist=" (:album-artists sobj))
                "-metadata" (str "date=" (:album-publish-time sobj))
                "-metadata" (str "publisher=" (:album-company sobj))
                "-metadata" (str "copyright=" (:album-company sobj))
                "-metadata" (str "release_type=" (:album-type sobj))
                "-metadata" (str "album_sub_type=" (:album-sub-type sobj))
                "-metadata" (str "source_song=https://music.163.com/song?id=" (:id sobj))
                "-metadata" (str "source_album=https://music.163.com/album?id=" (:album-id sobj))
                (when (not (nil? (:song-alias sobj))) ["-metadata" (str "alias=" (:song-alias sobj))])
                (when (not (nil? (:song-trans sobj))) ["-metadata" (str "trans_song=" (:song-trans sobj))])
                (when (not (nil? (:album-trans sobj))) ["-metadata" (str "trans_album=" (:album-trans sobj))])
                (if (= ".mp3" suffix)
                  ["-metadata" (str "lyrics=" lyric)
                   "-metadata" (str "track=" (:song-no sobj) "/" (:album-size sobj))]
                  ["-metadata" (str "lyrics=" lyric)
                   "-metadata" (str "tracknumber=" (:song-no sobj))
                   "-metadata" (str "tracktotal="  (:album-size sobj))])
                "-metadata" "download_tool=https://github.com/toure00/music-dl"
                f-path]]
    ;; downlaod music
    (when (not (file-exists? f-path))
      (let [arg (remove nil? (flatten f-args))]
           ;; (println (apply p/sh "ffmpeg" arg))
           (apply p/sh "ffmpeg" arg)))
    ;; downlaod lyrics
    (when (and (or (= (:dl @args!) "ext") (= ".mp3" suffix))
           (not (file-exists?  l-path)))
      (spit l-path lyric))))

(defn- main []
  (let [flag (set/intersection (set (keys @args!)) #{:pid :sid :aid :qs :ql})
        exec {:sid #(->> (get-music-info (:sid @args!))
                         download-music)
              :aid #(->> (get-album-list (:aid @args!))
                         (map download-music)
                         doall)
              :pid #(->> (get-music-list (:pid @args!))
                         (map download-music)
                         doall)
              :qs #(->> (query-music (:qs qargs) (:qs @args!))
                        select-music
                        get-music-info
                        download-music)
              :ql #(->> (query-music (:ql qargs) (:ql @args!))
                        select-music
                        get-music-list
                        (map download-music)
                        doall)}]
    (swap! args! assoc :path "./")
    (when (not (contains? @args! :l)) (swap! args! assoc :l (:level opt-data)))
    (when (not (contains? @args! :dl)) (swap! args! assoc :dl (:lyric opt-data)))
    (println @args!)
    (if (not= 1 (count flag))
      (println usage-doc)
      (do (println "Start...")
          (((first flag) exec))
          (println "Finish!")))))

(main)
