#!/usr/bin/env bb
(ns music.dl
  (:import
   [java.net URI URLEncoder])
  (:require
   [babashka.http-client :as http]
   [babashka.cli :as cli]
   [babashka.process :as p]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.set :as set]
   [cheshire.core :as json]
   [clojure.pprint :refer [print-table]]))

(def host "https://wyapi-2.toubiec.cn/api")
(def m-plist (str host "/getPlaylistDetail"))
(def m-info (str host "/getSongDetail"))
(def m-lyric (str host "/getLyric"))
(def durl-vers
  {:v1 {:url "https://wyapi.toubiec.cn/api/music/url" :fn (fn [x] (:url (first x)))}
   :v2 {:url (str host "/getMusicUrl") :fn (fn [x] (:url ((keyword (first (keys x)))x)))}})
(def curr-durl (:v2 durl-vers))

(def netease-api "https://music.163.com/api")
(def netease-song-api (str netease-api "/song/detail/?id=%d&ids=[%d]"))
(def netease-search-api (str netease-api "/search/get/web?csrf_token=hlpretag=&hlposttag=&offset=0&total=true&limit=20&type=%d&s=%s"))
(def netease-lyric-api (str netease-api "/song/lyric?os=pc&lv=-1&id="))
(def args! (atom (cli/parse-opts *command-line-args* {:verbose false}) ))

(def usage-doc
  (str"Usage:\n"
      "  -pid,\tPlay list ID\n"
      "  -sid,\tSong ID\n"
      "  -qs,\tQuery song name\n"
      "  -ql,\tQuery song list\n\n"
      "Optional:\n"
      "  -dl,\tDownload lyric (default hard)\n"
      "  \t(lyric: hard(内嵌), ext(外挂))\n"
      "  -l,\tQuality level (default exhigh)\n"
      "  \t(level: standard,exhigh,lossless,hires,jyeffect,sky,jymaster)"))
;; standard：标准音质, exhigh：极高音质,
;; lossless：无损音质 hires：Hi-Res音质,
;; jyeffect：高清环绕声, sky：沉浸环绕声,
;; jymaster：超清母带

(def headers
  {"Content-Type" "application/json"
   "Accept" "application/json"
   "User-Agent" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
   "Sec-Fetch-Mode" "cors"
   })

(defn- request-url
  ([url]
   (-> (http/get url {:headers headers})
       :body
       (json/parse-string true)))
  ([url arg]
   (-> (http/post url {:headers headers :body (json/generate-string arg)})
       :body
       (json/parse-string true))))
     
(def qargs
  {:qs {:type 1
        :fn (fn [x]
               (->> x
                    :songs
                    (map #(hash-map :id (:id %) :desc (str (:name %) " - " (:name (first (:artists %))))))))}
   :ql {:type 1000
        :fn (fn [x]
               (->> x
                    :playlists
                    (map #(hash-map :id (:id %) :desc
                                    (format "%s - (共 %d 首) - (播放量:%d) - (收藏量:%d)"
                                            (:name %) (:trackCount %) (:playCount %) (:bookCount %))))))}})

(defn- select-music [qlist]
  (doseq [ql qlist]
    (println (str (first ql) ". " (:desc (last ql)))))
  (println "input number:")
  (let [choice (Integer/parseInt (read-line))
        selected (last (nth qlist choice))]
    (println "selected:" (:desc selected))
    (println "id:" (:id selected))
    (:id selected)))

(defn- query-music [qarg name]
  (let [type (:type qarg)
        fn (:fn qarg)]
    (->> (request-url (format netease-search-api type (URLEncoder/encode name)))
         :result
         fn
         (map-indexed vector))))

(defn- check-link [link]
  (cond
    (nil? link) " -- 已失效"
    (str/includes? link ".mp3") ".mp3"
    (str/includes? link ".flac") ".flac"))

(defn- get-music-dlink [sid]
  (-> (request-url (:url curr-durl) {:id (str sid) :level (:l @args!)})
      :data
      ((:fn curr-durl))))

(defn- handle-song-info [s-info]
  (let [picurl (if (contains? s-info :picUrl) (:picUrl s-info) (:picimg s-info))
        singer (if (contains? s-info :artists) (:artists s-info) (:singer s-info))
        nm-info (first (:songs (request-url (format netease-song-api (:id s-info) (:id s-info)))))
        nm-album (:album nm-info)]
    {:id (:id s-info)
     :picurl picurl
     :name (:name s-info)
     :album (:album s-info)
     :singer singer
     :song-no (:no nm-info)
     :song-alias (if (empty? (:alias nm-info)) nil (str/join "," (:alias nm-info)))
     :song-trans (:transName nm-info)
     :album-id (:id nm-album)
     :album-artists (str/join "," (map #(:name %) (:artists nm-album)))
     :album-trans (:transName nm-album)
     :album-type (:type nm-album)
     :album-sub-type (:subType nm-album)
     :album-size (:size nm-album)
     :album-publish-time (.format (java.text.SimpleDateFormat. "yyyy-MM-dd") (java.util.Date. (:publishTime nm-album)))
     :album-company (:company nm-album)
     :path (str (:path @args!) (str/replace (:name s-info) "/" " ") " - " (str/replace singer "/" "&"))}))

(defn- get-music-list [pid]
  (println "Get playlist...")
  (let  [data (:data (request-url m-plist {:id (str pid)}))]
    ;; 创建歌单目录
    (println "Create playlist dir...")
    (when (not (.exists (io/file (:name data))))
      (.mkdir (io/file (:name data))))
    ;; 设置歌单名变量
    (println "Set playlist dir var...")
    (swap! args! assoc :path (str "./" (:name data) "/"))
    (println @args!)
    (->> data
         :tracks
         (map handle-song-info))))

(defn- get-music-info [sid]
  (-> (request-url m-info {:id (str sid)})
      :data
      handle-song-info))

(defn- get-lyric [sid]
  (let [data (:data (request-url m-lyric {:id (str sid)}))]
    (if (= (:tlyric data) "")
      (:lrc data)
      (->> data
           ((fn [x] (str (:lrc x) (:tlyric x))))
           (#(str/replace % "[" ""))
           (str/split-lines)
           (map #(str/split % #"]"))
           (reduce (fn [acc [k v]] (update acc (keyword (str k)) (fnil conj []) v)) (sorted-map))
           (map flatten)
           ;; 换行
           ;; (map #(str "[" (name (first %) ) "]" (str/join " / " (remove nil? (rest %)))))
           ;; 同一行
           (map #(str "[" (name (first %)) "]" (second %)
                      (when (= 3 (count (remove nil? %)))
                        (str "\n" "[" (name (first %)) "]" (last %)))))
           (str/join "\n")))))

(defn- file-exists? [path]
  (if (not (.exists (io/file path)))
    (do (println (str "Downloading -> " path))
        false)
    (do (println (str "Exists..." path))
        (Thread/sleep 1000)
        true)))

(defn- download-music [sobj]
  ;; (print sobj)
  (let [dlink (get-music-dlink (:id sobj))
        suffix (check-link dlink)
        f-path (str (:path sobj) suffix)
        l-path (str (:path sobj) ".lrc")
        lyric (get-lyric (:id sobj))
        f-args ["-i" dlink
                "-i" (:picurl sobj)
                "-c" "copy"
                "-map" "0"
                "-map" "1"
                "-disposition:v:0" "attached_pic"
                "-metadata" "encoded_by=ffmpeg"
                "-metadata" (str "lyrics=" lyric)
                "-metadata" (str "title=" (:name sobj))
                "-metadata" (str "artist=" (:singer sobj))
                "-metadata" (str "album=" (:album sobj))
                "-metadata" (str "album_artist=" (:album-artists sobj))
                "-metadata" (str "date=" (:album-publish-time sobj))
                "-metadata" (str "publisher=" (:album-company sobj))
                "-metadata" (str "copyright=" (:album-company sobj))
                "-metadata" (str "RELEASETYPE=" (:album-type sobj))
                "-metadata" (str "album_sub_type=" (:album-sub-type sobj))
                "-metadata" (str "source_song=https://music.163.com/song?id=" (:id sobj))
                "-metadata" (str "source_album=https://music.163.com/album?id=" (:album-id sobj))
                (when (not (nil? (:song-alias sobj))) ["-metadata" (str "alias=" (:song-alias sobj))])
                (when (not (nil? (:song-trans sobj))) ["-metadata" (str "trans_song=" (:song-trans sobj))])
                (when (not (nil? (:album-trans sobj))) ["-metadata" (str "trans_album=" (:album-trans sobj))])
                (if (= ".mp3" suffix)
                  ["-metadata" (str "lyrics=" lyric)
                   "-metadata" (str "track=" (:song-no sobj) "/" (:album-size sobj))]
                  ["-metadata" (str "lyrics=" lyric)
                   "-metadata" (str "tracknumber=" (:song-no sobj))
                   "-metadata" (str "tracktotal="  (:album-size sobj))])
                f-path]]
    ;; downlaod music
    (when (not (file-exists? f-path))
      (let [arg (remove nil? (flatten f-args))]
           ;; (doall (map println arg))
           (apply p/sh "ffmpeg" arg)))
    ;; downlaod lyrics
    (when (and (= (:dl @args!) "ext")
           (not (file-exists?  l-path)))
      (spit l-path lyric))))

(defn- main []
  (let [flag (count (set/intersection (set (keys @args!)) #{:pid :sid :qs :ql}))]
    (swap! args! assoc :path "./")
    (when (not (contains? @args! :l)) (swap! args! assoc :l "exhigh"))
    (when (not (contains? @args! :dl)) (swap! args! assoc :dl "hard"))
    (println @args!)
    (if (not= 1 flag)
      (println usage-doc)
      (do (println "Start...")
          (cond
            (contains? @args! :pid) (->> (get-music-list (:pid @args!))
                                       (map download-music)
                                       doall)
            (contains? @args! :sid) (->> (get-music-info (:sid @args!))
                                       download-music)
            (contains? @args! :qs) (->> (query-music (:qs qargs) (:qs @args!))
                                      select-music
                                      get-music-info
                                      download-music)
            (contains? @args! :ql) (->> (query-music (:ql qargs) (:ql @args!))
                                      select-music
                                      get-music-list
                                      (map download-music)
                                      doall))
          (println "Finish!")))))

(main)
